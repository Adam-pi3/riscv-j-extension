[#background,reftext="Background"]
== Background

=== Definitions

We now define basic terms. Note that these rely on the definition of an “ignore” transformation, which is defined in Chapter 2.2.

* **Effective address (as defined in the RISC-V Base ISA):** A load/store effective addresses sent to the memory subsystem (e.g., as generated during the execution of load/store instructions). This does not include addresses corresponding to implicit accesses, such as page table walks.

* **Masked bits:** The top N bits of an address, where N is a configurable parameter (we will use N consistently throughout this document to refer to this parameter).

* **Transformed address:** An effective address after the ignore transformation has been applied.

* **Address translation mode:** The MODE of the currently active address translation scheme as defined in the RISC-V privileged specification. This could, for example, refer to Bare, Sv39, Sv48, and Sv57. In accordance with the privileged specification, non-Bare translation modes are referred to as virtual-memory schemes. For the purpose of this specification, M-mode translation is treated as equivalent to Bare.

* **Address validity:** The RISC-V privileged spec defines validity of addresses based on the privilege mode and address translation mode that is currently in use (e.g., Sv57, Sv48, Sv39, etc.). For an address to be valid, all bits in the unused portion of the address must be the same as the Most Significant Bit (MSB) of the used portion (for virtual addresses). For example, when page-based 48-bit virtual memory (Sv48) is used, load/store effective addresses, which are 64 bits, must have bits 63–48 all set to bit 47, or else a page-fault exception will occur. This definition only applies to virtual addresses.

* **NVBITS:** The upper bits within a virtual address that have no effect on addressing memory and are only used for validity checks. These bits depend on the currently active address translation mode. For example, in Sv48, these are bits 63-48.

* **VBITS:** The bits within a virtual address that affect which memory is addressed. These are the bits of an address which are used to index into page tables.

=== The “Ignore” Transformation

The ignore transformation (Listing 1) is expressed independently of the current address translation mode. Conceptually, it replaces the top N bits with the sign extension of the N+1st bit from the top.

[source]
."Ignore" Transformation expressed in Verilog code.
----
transformed_effective_address =
  {{N{effective_address[XLEN-N-1]}}, effective_address[XLEN-N-1:0]}
----

[NOTE]
====
If N is smaller or equal to NVBITS for the current address translation mode, this is equivalent to ignoring a subset of NVBITS. This enables cheap implementations that disable validity checks in the MMU instead of performing the sign extension.
====

When pointer masking is enabled, this transformation will be applied to every explicit memory access (e.g., loads/stores, atomics operations, and floating point loads/stores). The transformation *does not* apply to implicit accesses such as page table walks or instruction fetches. The set of accesses that pointer masking applies to is described in <<_memory_accesses_subject_to_pointer_masking>>.

[WARNING]
====
Pointer masking does not change the underlying address generation logic or permission checks. It is semantically equivalent to replacing a subset of instructions (e.g., loads and stores) with an instruction sequence that applies the ignore operation to the target address of this instruction and then applies the instruction to the transformed address. References to address translation and other implemenation details in the text are primarily to explain design decisions and common implementation patterns.
====

Note that pointer masking is purely an arithmetic operation on the address that makes no assumption about the meaning of the addresses it is applied to. Pointer masking with the same value of N always has the same effect. This ensures that code that relies on pointer masking does not need to be aware of the environment it runs in once pointer masking has been enabled, as long as the value of N is known. For example, the same application or library code can run in user mode, supervisor mode or M-mode (with different address translation modes) without modification.

[NOTE]
====
A common scenario for such code is that addresses are generated by mmap system calls. These system calls abstract away the details of the underlying address translation mode from the application code. Software therefore needs to be aware of the value of N to ensure that its minimally required number of tag bits is supported. <<_determining_the_value_of_n>> covers how this value is derived.
====

=== Example

Table 1 shows an example of address translation when PM is enabled for RV64 under Sv57 with N=7.

[%header, cols="25%,75%", options="header"]
.Example of PM address translation for RV64 under Sv57
|===
|Page-based profile|Sv57 on RV64
|Effective Address |0xAAFFFFFF12345678 +
NVBITS[1010101]  VBITS[11111111111111111111111110001...000]
|N|7
|Mask|0x01FFFFFFFFFFFFFF +
NVBITS[0000000]  VBITS[11111111111111111111111111111...111]
|N+1st bit from the top|1
|Transformed address |0xFFFFFFFF12345678 +
NVBITS[1111111]  VBITS[11111111111111111111111110001...000]

|===

=== Determining the Value of N

From an implementation perspective, ignoring bits is deeply connected to the address translation mode (e.g., Bare, Sv48, Sv57). In particular, applying the above transformation is cheap if it covers only the NVBITS (as it is equivalent to switching off validity checks) but expensive if the masked bits extend into the VBITS portion of the address (as it requires performing the actual sign extension). Similarly, when running in Bare or M mode, it is common for implementations to not use a particular number of bits at the top of the physical address range and pin them to zero. Applying the ignore transformation to all but the lowest of those bits is cheap as well (the lowest bit is still pinned to zero to ensure that sign extension will result in a valid physical address where all the top bits are zeros).

The specified extensions **do not** support N to be configurable. Instead, N is a static function of the currently active address translation mode. Specifically, N is the number of NVBITS of this address translation mode (e.g., 16 for Sv48) if it is a virtual-memory scheme. Pointer masking in Bare and M-mode address translation mode is a separate extension (`Smjpmbare16`). If this extension is present, N is hardcoded to be 16 in Bare and M-mode (otherwise it is 0).

[NOTE]
====
Future versions of the pointer masking extension may introduce the ability to configure the value of N. The current extension does not define the behavior if N was different from the values defined above. In particular, there is no guarantee that a future pointer masking extension would define the ignore operation in the same way for those values of N.
====

=== Pointer Masking and Privilege Modes

Pointer masking is controlled separately for different privilege modes. The subset of supported privilege modes is determined by the set of supported pointer masking extensions. Different privilege modes may have different pointer masking settings active simultaneously and the hardware will automatically apply the pointer masking settings of the currently active privilege mode. A delegation mechanism allows higher privilege modes to optionally restrict lower privilege modes from changing their own pointer masking settings (Chapter 3).

[NOTE]
====
Since pointer masking forms the foundation for security-related mechanisms, configurability per-privilege mode is critical for avoiding a window in time (e.g., when jumping into a trap handler) when the incorrect masking is applied.
====

Note that the pointer masking setting that is applied only depends on the active privilege mode, not on the address that is being masked. Some operating systems (e.g., Linux) may use certain bits in the address to disambiguate between different types of addresses (e.g., kernel and user-mode addresses). Pointer masking _does not_ take these semantics into account and is purely an arithmetic operation on the address it is given.

[NOTE]
====
Linux places kernel addresses in the upper half of the address space and user addresses in the lower half of the address space. As such, the MSB is often used to identify the type of a particular address. With pointer masking enabled, this role is now played by the N+1st bit and code that checks whether a pointer is a kernel or a user address needs to inspect this bit instead. For backward compatibility, it may be desirable that the MSB still indicates whether an address is a user or a kernel address. An operating system's ABI may mandate this, but it does not affect the pointer masking mechanism itself. For example, the Linux ABI may choose to mandate that the MSB is not used for tagging and replicates the N+1st bit.
====

=== Memory Accesses Subject to Pointer Masking

Pointer masking applies to all explicit memory accesses. In the Base and Privileged ISAs, these are:

* **Base Instruction Set**: LB, LH, LW, LBU, LHU, LWU, LD, SB, SH, SW, SD.
* **Atomics**: All instructions in RV32A and RV64A.
* **Floating Point**: FLW, FLD, LFQ, FSW, FSD, FSQ.
* **Compressed**: All instructions mapping to any of the above, and C.LWSP, C.LDSP, C.LQSP, C.FLWSP, C.FLDSP, C.SWSP, C.SDSP, C.SQSP, C.FSWSP, C.FSDSP.
* **Memory Management**: FENCE, FENCE.I (if the currently unused address fields become enabled in the future), SFENCE.\*, HFENCE.*, SINVAL.\*, HINVAL.*.

MPRV affects pointer masking as well, causing the pointer masking settings of the effective privilege mode to be applied. Just like in the absence of pointer masking, MPRV does not affect instruction fetch and the current rather than the effective privilege mode's pointer masking settings are applied to instructions. Pointer masking also applies to HLV, HLVX and HSV instructions.

For other extensions, pointer masking applies to all explicit memory accesses by default. This includes, e.g., vector loads and stores. Future extensions may add specific language to indicate whether particular accesses are or are not included in pointer masking.

[NOTE]
====
It is important to note that Cache Management Operation (CMO) must respect and take into account Pointer masking. Otherwise, a few serious security problem can appear, including:

* CBO.ZERO may work as a STORE operation and if Pointer Masking is not respected, it will be possible to write to the memory bypassing the masking enforcement
* If CMO won’t respect PM it would be possible to weaponize it in side-channel attack e.g., U-mode would be able flush PA address (without masking) that it should not be permitted to
====

Pointer masking only applies to accesses generated by instructions on the CPU (including CPU extensions such as an FPU). For example, it does not apply to accesses generated by the IOMMU or devices.

Misaligned accesses are supported, subject to the same limitations that would exist in the absence of pointer masking. If a misaligned access crosses the boundary to the masked bits, it will behave as if the ignore transformation is applied to each constituent access and thus "wrap around". This ensures that both hardware implementations and emulation of misaligned accesses in M-mode behave the same way.

No pointer masking operations are applied when software reads/writes to CSRs meant to hold addresses. If software needs to put tagged addresses into such CSRs, data load or data store operations based on those addresses are subject to pointer masking only if they are explicit (<<_memory_accesses_subject_to_pointer_masking>>) and pointer masking is enabled for the privilege mode that performs the access. For example, software is free to write a tagged or untagged address to `stvec`, but on trap delivery (e.g., due to an exception or interrupt), no pointer masking will be applied.

There is no guarantee that reading a CSR containing an address will retain any masked bits, even if a tagged address was previously written into this CSR.

=== Constituent Extensions

As indicated in <<_introduction>>, pointer masking refers to a number of separate extensions. This approach is used to capture optionality of pointer masking features. Profiles and implementations may choose to support an arbitrary subset of these extensions.

**Unprivileged Extension**:

* **Zjpm**: U/VU-mode pointer masking is available if and only if this extension is present.

**Privileged Extensions**:

* **Ssjpm**: S/HS/VS-mode pointer masking is available if and only if this extension is present.
* **Smjpm**: M-mode pointer masking is available if and only if this extension is present.
* **Smjpmbare16**: Pointer masking applies to the Bare address translation mode, across all supported privilege modes. If this extension is present, N is hardcoded to 16 in Bare address translation mode. If it is not present, N is hardcoded to 0 in Bare address translation mode.

Pointer masking only applies to RV64. On RV32, trying to enable pointer masking will cause an exception (see <<_unprivileged_isa_extensions>> and <<_privileged_isa_extensions>> for details). The same is the case on RV64 or larger systems when UXL/SXL/MXL is set to 1 for the corresponding privilege mode. Note that even on RV32, the CSRs introduced by pointer masking are still present, for compatibility between RV32 and larger systems with UXL/SXL/MXL set to 1.

