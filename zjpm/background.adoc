[#background,reftext="Background"]
== Background

=== Definitions

We now define basic terms. Note that these rely on the definition of an “ignore” transformation, which is defined in Chapter 2.2.

* **Effective address (as defined in the RISC-V Base ISA):** An address generated by the instruction fetch and load/store effective addresses sent to the memory subsystem. There is no special distinction of physical vs. virtual memory. This does not include addresses corresponding to implicit accesses, such as page table walks.

* **Masked bits:** The top N bits of an address, where N is a configurable parameter (we will use N consistently throughout this document to refer to this parameter).

* **Masked address:** An effective address after the ignore transformation has been applied to it.

* **Address translation mode:** The MODE of the currently active address translation scheme as defined in the RISC-V privileged specification. This could, for example, refer to Bare, Sv39, Sv48, and Sv57. In accordance with the privileged specification, non-Bare translation modes are refered to as virtual-memory schemes.

* **Address canonicity:** The RISC-V privileged spec defines canonicity of an address based on the privilege mode and address translation mode that is currently in use (e.g., Sv57, Sv48, Sv39, etc.). Canonicity enforces that for the translated addresses all bits in the unused portion of the address must be the same as the Most Significant Bit (MSB) of the used portion (for virtual addresses). For example, when page-based 48-bit virtual memory (Sv48) is used, instruction fetch addresses and load/store effective addresses, which are 64 bits, must have bits 63–48 all set to bit 47, or else a page-fault exception will occur. For untranslated addresses (i.e., for Bare and M-mode) canonicity requirement is for the high bits to be all zeros.

* **NVBITS:** The upper bits within an address that have no effect on addressing memory and are only used for canonicity checks. For example, in Sv48, these are bits 63-48.

* **VBITS:** The bits within an address that affect which memory is addressed.

=== The “Ignore” Transformation

The ignore transformation (Listing 1) is expressed independently of the current address translation mode. Intuitively, it replaces the top N bits with the sign extension of the N+1st bit from the top. If N is smaller or equal to NVBITS for the current address translation mode, this is equivalent to ignoring the NVBITS of the address, without actually performing the sign extension operation.

[source]
."Ignore" Transformation
----
transformed_effective_address =
  {{N{effective_address[XLEN-N-1]}}, effective_address[XLEN-N-1:0]}
----

When pointer masking is enabled, this transformation will be applied to every explicit memory access that is subject to the regular memory access path (i.e., subject to the current address translation mode). This includes, for example, atomics operations and floating point loads/stores. The transformation *does not* apply to implicit accesses such as page table walks, with the exception of instruction fetches if the corresponding pointer masking feature is enabled.

When pointer masking is enabled, address canonicity checks will be disabled.

=== Allowed values of N

Ignoring bits is deeply connected to the address translation mode (e.g., Bare, Sv48, Sv57). In particular, applying the above transformation is cheap if it covers only the NVBITS (as it is equivalent to switching off canonicity checks) but expensive if the masked bits extend into the VBITS portion of the address (as it requires performing the actual sign extension).

Systems may therefore choose to disallow certain values of N. The minimum set of values of N that must be supported may be defined by an ISA profile. The supported values of N may differ between privilege modes and between address translation modes.

When trying to enable pointer masking and setting a value of N in the corresponding CSR (Chapter 3), an implementation may choose a different value of N and reflect this in the updated register value. It may choose a larger number of bits than the original requested number if and only if the additional bits that are masked have no impact on addressing under the current privilege mode and address translation mode. If a smaller value of N is returned, the implementation should choose the largest supported value smaller or equal to the requested number of masked bits.

We expect that the initial profile will only mandate that systems support one value of N: The number of NVBITS of the current privilege mode and address translation mode (which is equivalent to disabling the canonicity check).

=== Example

Table 1 shows an example of address translation when PM is enabled for RV64 under Sv57 with N=8.

[%header, cols="25%,75%", options="header"]
.Example of PM address translation for RV64 under Sv57
|===
|Page based profile|Sv57 on RV64
|Effective Address|0xAAFFFFFF12345678

NVBITS[1010101]  VBITS[01111111111111111111111110001...000]
|N|8
|Mask|0x00FFFFFFFFFFFFFF

NVBITS[0000000]  VBITS[01111111111111111111111111111...111]
|N+1st bit from the top|1
|Transformed address|0xFFFFFFFF12345678

NVBITS[1111111]  VBITS[11111111111111111111111110001...000]

|===

