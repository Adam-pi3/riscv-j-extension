== ISA Extensions

This section describes the pointer masking extensions `Smmpm`, `Smnpm` and `Ssnpm`. All of these extensions are privileged ISA extensions and do not add any new CSRs.

[NOTE]
====
Future extensions may introduce additional CSRs to allow different privilege modes to modify their own pointer masking settings. This may be required for future use cases in managed runtime systems that are not currently addressed as part of this extension.
====

Each extension introduces a 2-bit WARL field (`PME`) that may take on the following values to set the pointer masking settings for a particular privilege mode.

[%header, cols="25%,75%", options="header"]
.Possible values of `PME` WARL field.
|===
|Value|Description
|00|Pointer masking is disabled (PMLEN=0)
|01|Reserved
|10|Pointer masking is enabled with PMLEN=XLEN-57 (PMLEN=7 on RV64)
|11|Pointer masking is enabled with PMLEN=XLEN-48 (PMLEN=16 on RV64)
|===

All of these fields are read-only 0 on RV32 systems.

=== Ssnpm

`Ssnpm` adds a new 2-bit WARL field (`PME`) to bits 33:32 of `senvcfg`. Setting `PME` enables or disables pointer masking for the next lower privilege mode (U/VU mode), according to the values in Table 2.

In systems where the H Extension is present, `Ssnpm` also adds a new 2-bit WARL field (`PME`) to bits 33:32 of `henvcfg`. Setting `PME` enables or disables pointer masking for VS-mode, according to the values in Table 2.

=== Smnpm

`Smnpm` adds a new 2-bit WARL field (`PME`) to bits 33:32 of `menvcfg`. Setting `PME` enables or disables pointer masking for the next lower privilege mode (S-/HS-mode if S-mode is implemented, or U-mode otherwise), according to the values in Table 2.

[NOTE]
====
The type of address determines which type of pointer masking is applied. For example, when running with virtualization in VS/VU mode with `vsatp.MODE` = Bare, physical address pointer masking (zero extension) applies.
====

=== Smmpm

`Smmpm` adds a new 2-bit WARL field (`PME`) to bits 33:32 of `mseccfg`. The presence of `Smmpm` implies the presence of the `mseccfg` register, even if it would not otherwise be present. Setting `PME` enables or disables pointer masking for M mode, according to the values in Table 2.

=== Interaction with SFENCE.VMA

Since pointer masking applies to the effective address only and does not affect any memory-management data structures, no SFENCE.VMA is required after enabling/disabling pointer masking.

=== Number of Masked Bits

As described in <<_determining_the_value_of_pmlen>>, the number of masked bits depends on the effective privilege mode. The current standard only supports PMLEN=XLEN-48 and PMLEN=XLEN-57, but this assumption may be relaxed in future extensions and profiles. Trying to enable pointer masking in an unsupported scenario represents an illegal write to the corresponding pointer masking enable bit and follows WARL semantics. Future profiles may choose to define certain combinations of privilege modes and supported values of PMLEN as mandatory.

[NOTE]
====
Implementations may feel tempted to set PMLEN depending on the current addressing modes, and profiles may set a valid range of PMLEN that allows such implementations. For example, PMLEN could be set to 16 for Sv48 and to 25 for Sv39. However, having a single value of PMLEN (e.g., setting PMLEN to 16 for both Sv39 and Sv48 rather than 25) facilitates TLB implementations in designs that support Sv39 and Sv48 but not Sv57. 16 bits are sufficient for current pointer masking use cases but allow for a TLB implementation that matches against the same number of virtual tag bits independently of whether it is running with Sv39 or Sv48. However, if Sv57 is supported, tag matching may need to be conditional on the current address translation mode.
====
