[[risc-v-pointer-masking-proposal]]
# RISC-V Pointer Masking proposal

_Adam Zabrocki_, _Lee Campbell_, _Martin Maas_, _RISC-V TEE_ and _J Extension Task Groups_

**Contributors: ** [Members of the TEE and J Extension Task Groups]

[[introduction]]
## Introduction

RISC-V Pointer Masking (PM) is a feature which provides a possibility of implementing “memory tagging” by ignoring various bits (defined by mask) of the [.underline]#_effective address_# (virtual or physical) on RV128, RV64 and RV32.

[.underline]#_Effective address_# is an address generated by the address generation logic before it is sent to the memory subsystem. As such, there is no special handling of physical vs. virtual memory at the software level.

Memory tagging (MT) is a technique which can significantly improve the memory safety state of any application (including code running in more privileged modes). MT can be fully implemented in the hardware or partially hardware assisted. However, both implementations require a PM feature to be enabled to not overwhelm the performance.

General idea of MT is based on assigning a tag to every granule of memory (a small, e.g. 16-byte, naturally aligned memory region). All accesses to memory must be made via a pointer with the correct tag. Use of an incorrect tag is noted and the monitor software can choose what to do with such a situation (e.g. could be killing the process, or just report it to the user immediately). To be able to store the tag in every memory pointer (poisoning the pointer) and correctly using it in running applications without significant performance impact, PM is necessary.

This document proposes an extension for RISC-V called PM (Pointer Masking) which in the future might be enhanced for implementing a full hardware memory tagging.

[[proposal]]
## Proposal

We propose to add:

* new PM configuration CSR register called _**MMTE**_ (Memory Tagging Extension)
* new PM pointer masking CSR register for each privilege level called _**MPMMASK**_ (Pointer Masking Mask)
* new PM pointer base CSR register for each privilege level called _**MPMBASE**_ (Pointer Masking Base)

Restricted views of the _**mmte**_ register appear as the _**hmte**_, _**smte**_ and _**umte**_ registers in the HS-level, VS-level and (V)U-level ISAs respectively.

Each privilege level has own copy of pointer masking CSR register. It appears as the _**mpmmask**_, _**hpmmask**_, _**spmmask**_ and _**upmmask**_ registers in the M-level, HS-level, VS-level and (V)U-level ISAs, respectively.

Each privilege level has its own copy of pointer base CSR register. It appears as the _**mpmbase**_, _**hpmbase**_, _**spmbase**_ and _**upmbase**_ registers in the M-level, HS-level, VS-level and (V)U-level ISAs, respectively.

The purpose of the _**mpmmask**_ register is to be able to precisely define a mask whose bits of the effective address are ignored. The actual address can be calculated by using requested address and _**mpmmask**_ register.

Additionally, _**mpmbase**_ register can be defined, allowing to replace those bits of the actual_address which are defined to be masked by _**mpmmask**_. _**mpmbase**_ can be configured to replace only the subset of the masked bits, and the remaining are still ignored and can be used for any purpose (e.g. memory tagging).

If _**mpmbase**_ register is set (has value other than zero), actual address can be calculated by using requested address, _**mpmmask**_ and _**mpmbase**_ register:

[source]
----
actual_address = (requested_address & ~mpmmask) | (mpmbase & mpmmask)
----
Equation 1.

_**mpmbase**_ register can be read-only and hardwired to 0. In such case, the actual address will be calculated only by using requested address and _**mpmmask**_ register.

When PM extension is enabled, _**mpmmask**_ and _**mpmbase**_ registers allow to implement in-process isolation feature. That feature allows for each thread to be isolated to a given block of the address space. It can be used to isolate untrusted code within a process. A high-level concept can be seen on Picture 1.

image:media/image1.png[image,width=451,height=394]

Picture 1: In-Process isolation leveraging _**mpmmask**_ and _**mpmbase**_ registers

_**MMTE**_ layout can be found in Figure 1a, 1b, 1c and 1d for M, HS, VS and (V)U-mode. +

_**MPMMASK**_ layout can be found in Figure 2a, 2b, 2c and 2d for M, HS, VS and (V)U-mode. +

_**MPMBASE**_ layout can be found in Figure 3a, 3b, 3c and 3d for M, HS, VS and (V)U-mode. +

Table 1 explains the meaning of _PM_ bits for RV32, RV64 and RV128. +

[%header, cols=5*]
,===
mmte[XLEN-1:15],mmte[7:6],mmte[5:4],mmte[3:2],mmte[1:0]
WPRI,M-mode PM,HS-mode PM,VS-mode PM,(V)U-mode PM
,===
Figure 1a: Memory Tagging Extension register (_**mmte**_) M-MODE +
 +

[%header, cols=4*]
,===
hmte[XLEN-1:15],hmte[5:4],hmte[3:2],hmte[1:0]
WPRI,HS-mode PM,VS-mode PM,(V)U-mode PM
,===
Figure 1b: Memory Tagging Extension register (_**hmte**_) HS-mode +
 +

[%header, cols=3*]
,===
smte[XLEN-1:15],smte[3:2],smte[1:0]
WPRI,VS-mode PM,(V)U-mode PM
,===
Figure 1c: Memory Tagging Extension register (_**smte**_) for S-mode +
 +

[%header, cols=2*]
,===
umte[XLEN-1:15],umte[1:0]
WPRI,(V)U-mode PM
,===
Figure 1d: Memory Tagging Extension register (_**umte**_) for U-mode +
 +

[cols="15%,15%,70%", options="header"]
|===========================================================================================================================
^|*PM Bits* ^|*Name* ^|*Meaning*
^.^| PM[0:0] ^.^| PM.Enabled |

  0 – PM is disabled (_default_) +
  1 – PM is enabled

^.^| PM[1:1] ^.^| PM.Current |

 0 – _**xPMMASK**_ and _**xPMBASE**_ registers can only be modified by the higher privilege level +
 1 – _**xPMMASK**_ and _**xPMBASE**_ registers can be modified by the same privilege level

|===========================================================================================================================
Table 1: Meaning of _PM_ bits for RV32, RV64 and RV128 +
 +

[%header, cols=1*]
,===
mpmmask[XLEN-1:0]
MASK
,===
Figure 2a: Memory Tagging Extension register (_**mpmmask**_) for M-MODE +
 +

[%header, cols=1*]
,===
hpmmask[XLEN-1:0]
MASK
,===
Figure 2b: Memory Tagging Extension register (_**hpmmask**_) for HS-MODE +
 +

[%header, cols=1*]
,===
spmmask[XLEN-1:0]
MASK
,===
Figure 2c: Memory Tagging Extension register (_**spmmask**_) for S-MODE +
 +

[%header, cols=1*]
,===
upmmask[XLEN-1:0]
MASK
,===
Figure 2d: Memory Tagging Extension register (_**upmmask**_) for U-MODE +
 +
 +

[%header, cols=1*]
,===
mpmbase[XLEN-1:0]
BASE
,===
Figure 3a: Memory Tagging Extension register (_**mpmbase**_) for M-MODE +
 +

[%header, cols=1*]
,===
hpmbase[XLEN-1:0]
BASE
,===
Figure 3b: Memory Tagging Extension register (_**hpmbase**_) for HS-MODE +
 +

[%header, cols=1*]
,===
spmbase[XLEN-1:0]
BASE
,===
Figure 3c: Memory Tagging Extension register (_**spmbase**_) for S-MODE +
 +

[%header, cols=1*]
,===
upmbase[XLEN-1:0]
BASE
,===
Figure 3d: Memory Tagging Extension register (_**upmbase**_) for U-MODE +
 +

[[explanation]]
## Explanation

_**MMTE**_ register fulfills two-fold function:

1. Can only be programmable by more privileged mode (unless PM.Current bit is enabled) +
2. Performs status register function for the current privilege mode +

_PM_ bits from **_MMTE_** register are accessible in all modes ((V)U/VS/HS/M) and can be read to query if the PM feature is currently enforced. By default, only higher privileged code can set the value for _PM_ bits. However, higher privileged code can enable _PM.Current_ bit for lower privileged code. In such scenario, current privilege code has a possibility to self-manage its own configuration of _PM_ bits.

PM bits for VU and U mode are special. If virtualization extension is enabled, PM extension can be configured only for VU mode (using (V)U bits) but not for U mode. If virtualization extension is disabled, PM bit for (V)U are configuring PM extension for U mode. It is not allowed (and not possible) to enable PM extension for U mode when virtualization is enabled. In such environment (V)U bits are configuring PM for VU-mode.

By default, the current CPU mode is using _**xPMMASK**_, _**xPMBASE**_ and _PM_ bits corresponding to it. When CPU is switching the mode, corresponding pair of _**xPMMASK**_, _**xPMBASE**_ and _PM_ bits are used.

If higher privileged code needs to use _**xPMMASK**_ and _**xPMBASE**_ from the lower privilege mode, there are two possible solutions: +
1. Emulate equation 1. purely in software using _**xPMMASK**_ and  _**xPMBASE**_ CSRs from the desired privilege mode. +
2. If PM.Current is enabled it is possible to save the state of the current _**xPMMASK**_ and _**xPMBASE**_ CSRs and temporarily replace them with the desired one. At the end, original values can be restored. +


_**MPMMASK**_ register fully two-fold function:

1.  Based on PM bits configuration, it can be programmable by the higher privilege mode or by the current privilege mode +
2.  Performs status register function for the current privilege mode +

_**MPMBASE**_ register fully two-fold function:

1.  Based on PM bits configuration, it can be programmable by the higher privilege mode or by the current privilege mode
2.  Performs status register function for the current privilege mode

Any write access would be ignored if performed to the current _**xPMMASK**_, _**xPMBASE**_ and **_MMTE_** CSR registers and PM.Current is disabled.

